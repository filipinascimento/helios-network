# Agent Notes (Helios Network v2)

This repository is a WebAssembly-first graph store: a C17/C23 core compiled with Emscripten plus a JavaScript wrapper/API.

## Nonâ€‘negotiables (WASM + performance)

1) **WASM views can become invalid after allocation / memory growth.** Any `TypedArray` that views `wasmMemory.buffer` (dense buffers, sparse attribute buffers, index buffers, etc.) may be detached/repointed when the WASM heap grows. Do not cache these views across calls that might allocate.

2) **Avoid duplication.** Prefer operating on WASM-backed buffers and passing views through (e.g. to WebGL/WebGPU). Avoid creating/keeping JS-side copies of large buffers, except when you explicitly need a *dense packed* snapshot (dense buffers) or there is no alternative.

Clarification:
- **Dense packed buffers are OK** as a form of duplication **inside WASM** (they are an intentional, GPU-friendly repack into contiguous linear memory).
- **Avoid duplication outside WASM**: do not materialize or retain large JS-owned copies of WASM data (e.g. `Array.from(view)`, `view.slice()`, `Uint8Array.from(...)`, spreading into `number[]`), unless there is no other way.

Practical rule: **allocate first, view second**.

- Do allocation-prone work *before* taking any `TypedArray` views.
- Then access buffers inside `withBufferAccess(...)` (or `startBufferAccess()` / `endBufferAccess()`) so allocation-prone calls throw instead of silently invalidating views.

Relevant docs:
- `docs/dense-buffer-sessions.md`
- `docs/visualization-buffers.md`

## Quickstart (common commands)

- Install: `npm install`
- Build WASM artefacts (Emscripten + Meson): `npm run build:wasm` (regenerates `compiled/CXNetwork.{mjs,wasm}`)
- Build JS bundles (Vite/Rollup): `npm run build` (writes to `dist/`)
- Tests (Node/Vitest): `npm test`
- Browser tests (optional): `npm run test:browser`

## Where to make changes

- JS public API: `src/js/HeliosNetwork.js`, `src/helios-network.js`, `src/helios-network-inline.js`
- WASM/native core (C): `src/native/include/helios/` and `src/native/src/`
- Build glue:
  - Emscripten build: `meson.build`, `emscripten-cross.txt`, `npm run build:wasm`
  - Bundle build: `vite.config.js`, `npm run build`

Generated / do-not-hand-edit:
- `compiled/` (WASM + Emscripten JS wrapper output)
- `dist/` (bundles)
- `src/js/inline/wasm-inline.js` (generated by `scripts/generate-inline-wasm.mjs`)

## Buffer access patterns (how to not break views)

- Treat anything that may allocate as unsafe while holding views, including:
  - `addNodes`, `addEdges`, attribute (re)definitions, removals
  - dense repack calls like `updateDense*` (they may grow WASM memory)
  - helpers that return JS-owned copies (e.g. `nodeIndices` / `edgeIndices`)
- Preferred pattern:
  - Call `updateDense*` for everything you need (may allocate).
  - Enter `withBufferAccess` and only then obtain views (`getDense*View`, `get*AttributeBuffer`, etc.).
  - Use versions/topology versions (see `docs/versioning.md`) to decide whether to re-upload to GPU instead of copying every frame.

## File formats (xnet/bxnet/zxnet)

- Serialization and loading entry points are documented in `docs/saving-and-loading.md`.
- The authoritative XNET grammar is `docs/xnet-format.md`.

## When in doubt

- Prefer small, targeted changes; keep API behavior stable unless the task explicitly asks otherwise.
- If you need to touch both C and JS: update native code first, rebuild via `npm run build:wasm`, then update the JS wrapper and run `npm test`.
- When making substantial changes (new features, bug fixes), prefer adding or updating a test that covers the change.
- Run relevant tests after any change; for substantial changes run the full suite (`npm test` plus optional browser coverage via `npm run test:browser` when applicable).
