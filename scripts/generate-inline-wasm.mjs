#!/usr/bin/env node
import { readFileSync, writeFileSync, mkdirSync } from 'node:fs';
import { dirname, resolve } from 'node:path';
import { fileURLToPath } from 'node:url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const projectRoot = resolve(__dirname, '..');
const wasmPath = resolve(projectRoot, 'compiled/CXNetwork.wasm');
const outputDir = resolve(projectRoot, 'src/js/inline');
const outputFile = resolve(outputDir, 'wasm-inline.js');

function chunkBase64(source, length = 120) {
	const chunks = [];
	for (let idx = 0; idx < source.length; idx += length) {
		chunks.push(source.slice(idx, idx + length));
	}
	return chunks;
}

function generateModule(base64Data) {
	const chunks = chunkBase64(base64Data);
	const serialized = chunks.map((chunk) => `\t'${chunk}'`).join(',\n');
	return `// Auto-generated by scripts/generate-inline-wasm.mjs\nconst INLINE_WASM_BASE64 = [\n${serialized}\n].join('');\n\nlet cachedBinary = null;\n\nfunction decodeBase64ToBytes() {\n\tif (typeof Buffer !== 'undefined') {\n\t\treturn Uint8Array.from(Buffer.from(INLINE_WASM_BASE64, 'base64'));\n\t}\n\tif (typeof atob === 'function') {\n\t\tconst binary = atob(INLINE_WASM_BASE64);\n\t\tconst bytes = new Uint8Array(binary.length);\n\t\tfor (let idx = 0; idx < binary.length; idx += 1) {\n\t\t\tbytes[idx] = binary.charCodeAt(idx);\n\t\t}\n\t\treturn bytes;\n\t}\n\tthrow new Error('Inline WASM build requires Buffer or atob support to decode base64 data');\n}\n\nexport function getInlineWasmBinary() {\n\tif (!cachedBinary) {\n\t\tcachedBinary = decodeBase64ToBytes();\n\t}\n\treturn cachedBinary;\n}\n`;
}

function main() {
	const wasmBytes = readFileSync(wasmPath);
	const base64Data = Buffer.from(wasmBytes).toString('base64');
	mkdirSync(outputDir, { recursive: true });
	writeFileSync(outputFile, generateModule(base64Data), 'utf8');
	console.log(`Generated inline WASM helper at ${outputFile}`);
}

main();
